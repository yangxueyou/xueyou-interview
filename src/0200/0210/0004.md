### 实现 add(1)(2)(3)(4) = 10

https://github.com/BetaSu/fe-hunter/issues/2#issuecomment-1074694344
### 实现数组扁平化

```js
// 给你一个数组：[1, [2, 3, [4], 5], 6]
// 你需要输出： [1, 2, 3, 4, 5, 6]
```

参考答案：https://github.com/BetaSu/fe-hunter/issues/34#issuecomment-1082556189

### new 一个对象, 这个过程中发生了什么

```js
1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的prototype属性。
3. 将这个空对象赋值给函数内部的this关键字。
4. 开始执行构造函数内部的代码。
```

### 实现 _new 方法

```js
function _new(fn, ...args) {
  // 实现...
}

function Person(name, age) {
  this.name = name;
  this.age = age;
}
const kasong = _new(Person, 'KaSong', 18);
console.log(kasong.age); // 18

function Something(name) {
  this.name = name;
  return {name: 'something'};
}
const something = _new(Something, 'XiaoMing');
console.log(something.name); // something
```

参考答案：https://wangdoc.com/javascript/oop/new.html#new-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86

参考答案：https://github.com/BetaSu/fe-hunter/issues/15

```js
function _new(constructor, ...args) {
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.call(context, ...args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === 'object' && result != null) ? result : context;
}
```


### DOMContentLoaded


blocking script 会导致dom解析暂停，而 defer script 的下载是不会影响dom解析的。我理解defer的使用场景可以跟preload使用场景一致，defer和async的都不会阻塞dom解析，区别在于js文件加载后的执行顺序不同以及有无对DomContentLoaded的事件影响

https://zhuanlan.zhihu.com/p/25876048

### promise 有什么缺点？

promise 一旦初始化，就不能中止。还有执行的进度，不知道是刚刚开始还是要马上结束，这是由 promise 的实现决定的。

### 为什么有的编程规范要求用 void 0 代替 undefined？

undefined 是变量，为了防止其被篡改，直接使用 void（0），而且 undefined 也会自动编译成 void(0)，所以直接使用更好。 当有面试官问你怎样获取安全的 undefined 的时候你可以回答用 void 0；

### 字符串有最大长度吗？

2^53-1 （大约 9PB）

当然啦，实际引擎是不可能允许分配那么大的字符串的，你的电脑也没那么大存储不是。V8 的 heap 上限只有 2GB 不到，允许分配的单个字符串大小上限更只有大约是 512MB 不到。JS 字符串是 UTF16 编码保存，所以也就是 2.68 亿个字符。FF 大约也是这个数字。

### 0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？

浮点型运算由于有精度，就导致 0.1+0.2!=0.3,可以用 Math.abs(0.1+0.2-0.3)<=Number.EPSILON ，检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。Number.EPSILON 的实质是一个可以接受的最小误差范围。Math.abs() 返回一个数的绝对值。

### ES6 新加入的 Symbol 是个什么东西？

ES5 的对象属性名都是字符串，这容易造成属性名的冲突，ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值

### 为什么给对象添加的方法能用在基本类型上？

每一个基本类型都在对象中有相应的类（除了 symbol，但是可以装箱转换），因为运算符提供了装箱操作，它会根据基本类型构造一个临时对象，所以在基础类型上可以调用对应对象的方法

### script 的 derfer 和 async 的区别

```js
// 表示这是一个 ES6 模块，不是传统脚本
<script type="module" src="main.js"></script>
// 作为老式浏览器的回退方案。nomodule 这个属性通常与type="module"配合使用
<script nomodule src="fallback.js"></script>

```

- `<script>还有下面一些其他属性`
- async 浏览器立即异步下载文件，不同于 defer 得是，`下载完成会立即执行`，`此时会阻塞dom渲染`，所以 async 的 script 最好`不要操作dom`。因为是下载完立即执行，不能保证多个加载时的先后顺序。
- defer 是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个`页面都解析完毕后再运行`。浏览器渲染页面，读取到包含 defer 属性的外部`<script>`标签时不会停止 DOM 渲染，而是异步下载，加载完整个页面再运行 js。有多个 defer 的标签时，`会按照顺序下载执行`。
- crossorigin：如果采用这个属性，`就会采用跨域的方式加载外部脚本`，即 HTTP 请求的头信息会加上 origin 字段。Origin 指示了请求来自于哪个站点(`协议+域名+端口号`)
- integrity：`给出外部脚本的哈希值`，`防止脚本被篡改`。只有哈希值相符的外部脚本，才会执行。
- nonce：一个密码`随机数`，由`服务器在 HTTP 头信息里面给出`，每次加载脚本都不一样。它相当于给出了`内嵌脚本的白名单`，只有在白名单内的脚本才能执行。
- referrerpolicy：HTTP 请求的 Referer 字段的处理方法。(告诉服务器该网页是从哪个页面链接过来的,`携带着 url 的很多参数信息`，而这些信息实际上是隐私的，所以存在一定的隐私暴露风险。)

### 节流防抖的原理和使用场景

```js
防抖: 每次触发事件时都取消之前的延时调用方法
function debounce(fn) {
  let timeout = null; // 创建一个标记用来存放定时器的返回值
  return function () {
    clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => {
    // 然后又创建一个新的 setTimeout,
    // 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
    fn.apply(this, arguments);
   }, 500);
 };
}
function sayHi() {
  console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖

节流: 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function () {
    if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
    canRun = false; // 立即设置为false
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
     fn.apply(this, arguments);
     // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。
     // 当定时器没有执行的时候标记永远是false，在开头被return掉
     canRun = true;
    }, 500);
  };
}
function sayHi(e) {
 console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

```
应用场景:
debounce
1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存
throttle
1. scroll 事件，每隔一秒计算一次位置信息等
2. 浏览器播放事件，每隔一秒计算一次进度信息等
3. input框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)
```

### 手写 Promise

https://juejin.cn/post/6850037281206566919

https://www.zhihu.com/question/41986174/answer/93340999

### for...in 和 for...of 的区别

1. 推荐 for...of 遍历数组, for...in 循环对象

2. for...of 循环，作为遍历所有数据结构的统一的方法,一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员

3. for...in 循环出的是 key，for...of 循环出的是 value

4. for...of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for...in 循环也不一样。

```js
let arr = [3, 5, 7];
arr.foo = "hello";

for (let i in arr) {
  console.log(i); // "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); //  "3", "5", "7"
}
```

for...in：https://wangdoc.com/javascript/oop/object.html#in-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-forin-%E5%BE%AA%E7%8E%AF

for...for：https://wangdoc.com/es6/iterator.html#forof-%E5%BE%AA%E7%8E%AF

### 写出下面输出结果

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function () {
  console.log("setTimeout");
}, 0);
async1();
new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});
console.log("script end");
```

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    new Promise(function (resolve) {
        console.log('promise1');
        resolve();
    }).then(function () {
        console.log('promise2');
    });
}
console.log('script start');
setTimeout(function () {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function (resolve) {
    console.log('promise3');
    resolve();
}).then(function () {
    console.log('promise4');
});
console.log('script end')
// async2() 中.then()的代码先进入到promise的微任务队列，await async2(); 后面的代码再进入到promise的任务队列
```

```js
setTimeout(function () {
    console.log(1)
}, 0);

new Promise(function (resolve, reject) {
    console.log(2)
    for (var i = 0; i < 10000; i++) {
        if (i === 10) {
            console.log(10)
        }
        i == 9999 && resolve();
    }
    console.log(3)
}).then(function () {
    console.log(4)
})
console.log(5);
```

```js
console.log("start");
setTimeout(() => {
    console.log("children2")
    Promise.resolve().then(() =>{
        console.log("children3")
    })
}, 0)

new Promise(function(resolve, reject){
    console.log("children4")
    setTimeout(function(){
        console.log("children5")
        resolve("children6")
    }, 0)
}).then(res =>{         // flag
    console.log("children7")
    setTimeout(() =>{
        console.log(res)
    }, 0)
})
```

### setTimeout、Promise、Async/Await 的区别

```
事件循环中分为宏任务队列和微任务队列。

其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；

promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；

async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，
遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。
```

### 宏任务、微任务、RAF

https://blog.csdn.net/littlelyon/article/details/102927823

### 原型链

https://github.com/mqyqingfeng/Blog/issues/2

### 继承

https://segmentfault.com/a/1190000022677985

### 闭包

一句话解释: `能够读取其他函数内部变量的函数。`

- 应用场景

  - 回调函数
    - 发送 ajax 请求成功|失败的回调
    - setTimeout 的延时回调
  - 一个函数内部返回另一个匿名函数
  - 柯里化
  - 私有变量

- 闭包的缺点
  - 内存泄露
  - 不要随便改变父函数内部变量的值

### 柯里化

https://cloud.tencent.com/developer/article/1664434

### 跨域问题有哪些处理方式

- 跨域解决方案
  - 通过 jsonp 跨域
  - 跨域资源共享（CORS）
  - nodejs 中间件代理跨域
  - nginx 反向代理中设置 proxycookiedomain
  - H5 PostMessage：https://www.cnblogs.com/dolphinx/p/3464056.html
  - websocket
  - 本地 web 服务（也是nodejs）或者 cdn

1. 通过 jsonp 跨域

只能是 get 请求

JSONP 是通过动态`<script>`元素使用的，可以为`src`属性指定一个跨域 URL，`<script>`有能力从其他域加载资源。

```html
<script>
  var script = document.createElement("script");
  script.type = "text/javascript";

  // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
  script.src =
    "http://www.daxihong.com:8080/login?user=admin&callback=jsonCallback";
  document.head.appendChild(script);

  // 回调执行函数
  function jsonCallback(res) {
    alert(JSON.stringify(res));
  }
</script>
```

```js
// 服务器端返回如下(返回即执行全局函数)
jsonCallback({ status: 0, user: "admin" });
```

2. 跨域资源共享（CORS）

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与，只要服务器实现了 CORS 接口，就可以跨源通信；

两种方式：简单请求，非简单请求

非简单请求多一个预检请求的过程

JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

https://www.ruanyifeng.com/blog/2016/04/cors.html

```js
const path = require('path')
const Koa = require('koa')
const koaStatic = require('koa-static')
const bodyParser = require('koa-bodyparser')
const router = require('./router')
const cors = require('koa2-cors')
const app = new Koa()
const port = 9871

...
// 处理cors
app.use(cors({
  origin: function (ctx) {
    return 'http://localhost:9099'
  },
  credentials: true,
  allowMethods: ['GET', 'POST', 'DELETE'],
  allowHeaders: ['t', 'Content-Type']
}))
// 路由
app.use(router.routes()).use(router.allowedMethods())
// 监听端口
...
```

3. nodejs 中间件代理跨域

```js
module.exports = {
  entry: {},
  module: {},
  ...
  devServer: {
      historyApiFallback: true,
      proxy: [{
          context: '/login',
          target: 'http://www.daxihong.com:8080',  // 代理跨域目标接口
          changeOrigin: true,
          secure: false,  // 当代理某些https服务报错时用
          cookieDomainRewrite: 'www.daxihong.com'  // 可以为false，表示不修改
      }],
      noInfo: true
  }
}
```

4. nginx 反向代理中设置

和使用 node 中间件跨域原理相似。前端和后端都不需要写额外的代码来处理， 只需要配置一下 Ngnix

```js
server{
  # 监听9099端口
  listen 9099;
  # 域名是localhost
  server_name localhost;
  #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871
  location ^~ /api {
      proxy_pass http://localhost:9871;
  }
}
```

### 两次上传同样的文件怎么触发 onchange

```
一个<input type="file"/>两次上传同样的文件怎么触发onchange,用react怎么实现。
```

https://blog.csdn.net/cc18868876837/article/details/89194641

### fetch 发送 2 次请求的原因

https://blog.csdn.net/fyp_1995/article/details/89973824

### 怎么访问到 arr[-1]

```
1. proxy
2. valueOf
3. toString
```

### 实现斐波那契数列

```
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

for (let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n);
}
```

### 遍历任意对象（object）的方法

```js
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: "Jane", last: "Doe" };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

### 请实现一个 EventBus 模块

可以实现自定义事件的订阅、触发、移除功能，功能如下所示

```js
const eventBus = new EventBus();
function handleSleep1() {
  console.log("sleep1");
}
function handleSleep2() {
  console.log("sleep2");
}
function handleSleep3() {
  console.log("sleep3");
}
// 一堆监听
eventBus.on("sleep", handleSleep1);
eventBus.on("sleep", handleSleep2);
eventBus.on("sleep", handleSleep1);
eventBus.on("sleep", handleSleep3);
// 取消一个
eventBus.off("sleep", handleSleep3);
// 触发
eventBus.emit("sleep");
// 预期正确输出是（重复监听不生效、按监听顺序执行、取消的不生效）
// sleep1
// sleep2
// 全部取消
eventBus.off("sleep");
// 触发
eventBus.emit("sleep");
// 预期的正确输出是：没有输出
```

```js
// 我的代码：
class EventBus {
  constructor() {
    this.messages = {};
  }

  on(name, fn) {
    if (this.messages[name]) {
      let i = 0,
        isExist = false;
      while (i < this.messages[name].length) {
        if (this.messages[name][i] === fn) {
          isExist = true;
          break;
        }
        i++;
      }
      if (!isExist) {
        this.messages[name].push(fn);
      }
    } else {
      this.messages[name] = [fn];
    }
  }

  off(name, fn) {
    if (this.messages[name]) {
      if (!fn) {
        this.messages[name] = null;
        return;
      }
      let i = 0;
      while (i < this.messages[name].length) {
        if (this.messages[name][i] === fn) {
          this.messages[name].splice(i, 1);
          break;
        }
        i++;
      }
    }
  }

  emit(name) {
    if (!this.messages[name]) {
      return;
    }
    this.messages[name].forEach((cb) => {
      cb();
    });
  }
}
```

### 实现一个 lazyman 的链式调用

```js
LazyMan("Hank")
// 打印：Hi! This is Hank!

LazyMan("Hank").sleep(10).eat("dinner")
// 打印：Hi! This is Hank!
// 等待了 10 秒后
// 打印：Wake up after 10
// 打印：Eat dinner~
 
LazyMan("Hank").eat("dinner").eat("supper")
// 打印：Hi This is Hank!
// 打印：Eat dinner~
// 打印：Eat supper~
 
LazyMan("Hank").sleepFirst(5).eat("supper")
// 等待了 5 秒后
// 打印：Wake up after 5
// 打印：Hi This is Hank!
// 打印：Eat supper

LazyMan("Hank").eat("supper").sleepFirst(5)
// 等待了 5 秒后
// 打印：Wake up after 5
// 打印：Hi This is Hank!
// 打印：Eat supper
```

参考答案：https://github.com/BetaSu/fe-hunter/issues/13

```js
function LazyMan(name) {
  const { log } = console;

  const sleep = (s) =>
    new Promise((res) =>
      setTimeout(() => {
        log(`Wake up after ${s}`);
        res();
      }, s * 1000)
    );

  let queue = [() => log(`Hi! This is ${name}!`)];
  const ctx = {
    eat: (food) => queue.push(() => log(`Eat ${food}~`)) && ctx,
    sleep: (s) => queue.push(() => sleep(s)) && ctx,
    sleepFirst: (s) => queue.unshift(() => sleep(s)) && ctx,
  };
  queueMicrotask(async () => {
    while (queue.length) {
      await queue.shift()();
    }
  });
  return ctx;
}
```