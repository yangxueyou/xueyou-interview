## React应用卡顿该如何排查

https://github.com/BetaSu/fe-hunter/issues/3

## Redux 和 Vuex 区别

- 相同点
  - state 共享数据
  - 流程一致：定义全局state，触发，修改state
  - 原理相似，通过全局注入store

- 不同点
  - 从原理上来说：
    - Redux使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改
    - Redux在检测数据变化的时候，是通过diff的方式比较差异，而vuex其实和vue的原理一样，通过getter/setter
  - 从表现层来说：
    - Vuex定义了state、getter、mutation、action四个对象；redux定义了state、reducer、action。
    - vuex中state统一存放、方便理解；redux中state依赖所有reducer的初始值
    - vuex有getter，目的是快捷得到state、redux中没有这层、react-redux mapStateToProps参数做了这个工作
    - vuex中mutation知识单纯赋值；redux中reducer只是单纯设置新state，他俩作用类似，书写方式不同
    - vuex中action有较为复杂的异步ajax请求；redux中action中可简单可复杂，简单就直接发送数据对象（{type:xxx,your-data}），复杂需要调用异步ajax，依赖插件
    - vuex触发方式有两种--commit同步和dispatch异步；redux同步和异步都是使用dispatch

总结：vuex弱化dispatch，通过commit进行store状态的一次更改；取消了action概念，不必传入特定的action形式进行指定变更；弱化了reducer，基于commit参数直接对数据进行变更，使得框架更加简单
## Redux 中异步请求怎么处理的

一般的异步请求可以在 `componentDidmount`中直接进行请求

但在一定规范的项目中，上述方法很难进行异步流的管理，redux-thunk、redux-saga

### redux-thunk 中间件

- 优点：
  - 体积小：redux-thunk 的实现方式很简单，只有不到20行的代码
  - 使用简单：redux-thunk 没有引入像 redux-saga 或者 redux-observable 额外的规范，上手简单
- 缺陷：
  - 样板代码过多：与 redux 本身一样，通过一个请求需要大量的代码，而且很多都是重复的
  - 耦合严重：异步操作与 redux 的 action 耦合在一起，不方便管理
  - 功能弱：有些日常功能需要自己封装

### redux-saga

- 优点：
  - 异步解耦：异步操作被转移到单独saga.js中，不在是掺杂在 action.js 活 component.js 中
  - action摆脱thunk funtion：dispatch的参数依然是一个纯粹的action，而不是充满“黑魔法”thunk function
  - 异常处理：受益于generator function的saga实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理
  - 功能强大：redux-saga提供了大量的saga辅助函数和Effect创建器公寓开发者使用，开发者无需封装或者简单封装既可使用
  - 灵活：redux-saga可以将多个saga可以穿行/病情

## React 中 setState 是同步的还是异步

https://juejin.im/post/6844903636749778958

## React 事件绑定原理

https://github.com/lgwebdream/FE-Interview/issues/23

## Redux 和 Mobx 对比

https://blog.csdn.net/wang839305939/article/details/87908123

## react 16 To 17 生命周期有什么改变

https://reactjs.bootcss.com/docs/react-component.html#constructor


## react 15 To 16 底层架构的变化

React 16 之前的渲染流程： jsx 编译出的 render function 执行后产生 vdom，递归渲染 vdom，也就是增删改 dom，实现 render 和 patch

React 16 之后的渲染流程： jsx 编译出的 render function 执行后产生 vdom，通过空闲调度来慢慢的把 vdom 转成 fiber，vdom 转 fiber 的过程叫做 reconcile，最后都转完了就一次性渲染 fiber，也就是 commit，这样实现的 render 和 patch。之所以多了一层 vdom 转 fiber，是为了避免递归 patch 的时候需要做对比，而是通过可打断的方式来逐步计算如何修改 dom （是增、是删还是改）记录到 fiber 上，最后直接根据 fiber 直接增删改 dom。

## react.lazy 动态加载的原理

https://juejin.cn/post/6844904167664795662

## redux 如何改变状态

```
当一个action被执行的时候，我们可以去改变状态。

假设如下流程:

用户点击一个按钮

一个函数会被调用

一个action会被发出给处理容器， 这个容器需要用map dispatch to props来注册这个action。

Reducer会根据action来改变状态。

状态的改变会被处理容器注意到, map state to props。
```

## 解释一下 redux 里面的 store

```
Store存放应用程序的状态，并且有帮助函数来访问这些状态。

Store可以用来聆听变化和发送action。

Store只有一个。

你可以创建很多sub stores。
```

## 解释一下 redux 里面的 reducers

```
数据的状态是通过reducer函数来改变的。
```

## 解释一下 redux 里面的 actions

```
Actions代表的是一个对象。有两部分，一个是action本身，另一个就是它的payload。
简单说就是对哪些数据进行哪些操作。
```

## react-hook 的 useMemo 和 useCallBack 有什么区别

https://github.com/yangxueyou/hooks/blob/main/src/useMemo.js
